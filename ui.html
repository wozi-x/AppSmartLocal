<!DOCTYPE html>
<html>

<head>
    <style>
        :root {
            --primary-color: #18A0FB;
            /* Figma Blue */
            --primary-hover: #0D86D8;
            --bg-color: #FFFFFF;
            --text-color: #333333;
            --label-color: #5E5E5E;
            /* Muted text for labels */
            --border-color: #E6E6E6;
            --input-bg: #FFFFFF;
            --success-bg: #E6F9F0;
            --success-color: #0D7A4A;
            --success-border: #A3E4C9;
            --error-bg: #FFEAEA;
            --error-color: #C53030;
            --error-border: #F5A3A3;
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 12px;
            --spacing-lg: 16px;
            --radius-sm: 2px;
            /* Figma uses smaller radii */
            --radius-md: 6px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 11px;
            /* Figma standard is often 11px or 12px */
            color: var(--text-color);
            background: var(--bg-color);
            cursor: default;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .container {
            padding: var(--spacing-lg);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-lg);
        }

        /* Typography */
        .label {
            display: block;
            font-weight: 500;
            /* Inter Medium */
            margin-bottom: var(--spacing-xs);
            color: var(--label-color);
            font-size: 11px;
        }

        .hint {
            font-size: 10px;
            color: #888;
            margin-top: var(--spacing-xs);
            line-height: 1.4;
        }

        /* Inputs */
        input[type="text"],
        textarea {
            width: 100%;
            padding: var(--spacing-sm);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            font-family: inherit;
            font-size: 11px;
            background: var(--input-bg);
            color: var(--text-color);
            transition: border-color 0.15s ease-in-out;
        }

        input[type="text"]:focus,
        textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 1px var(--primary-color);
            /* Figma style focus */
        }

        input:hover,
        textarea:hover {
            border-color: #ccc;
        }

        input:focus:hover,
        textarea:focus:hover {
            border-color: var(--primary-color);
        }

        textarea {
            resize: vertical;
            min-height: 60px;
            line-height: 1.4;
        }

        textarea.tall {
            min-height: 100px;
            /* Reduced from 140px to save space */
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: var(--spacing-sm) var(--spacing-md);
            border: none;
            border-radius: var(--radius-md);
            font-family: inherit;
            font-size: 11px;
            font-weight: 600;
            /* Inter SemiBold */
            cursor: pointer;
            transition: all 0.1s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 32px;
            /* Standard button height */
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .btn-primary:hover {
            background: var(--primary-hover);
        }

        .btn-secondary {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }

        .btn-secondary:hover {
            border-color: #b3b3b3;
        }

        .btn-success {
            background: #1BC47D;
            color: white;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .btn-success:hover {
            background: #14a366;
        }



        .section {
            display: flex;
            flex-direction: column;
        }

        .flow-card {
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            background: #FAFAFA;
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
        }

        .flow-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .flow-step {
            background: #EAF4FC;
            color: #0A6FB6;
            border: 1px solid #B9DDF5;
            border-radius: 999px;
            padding: 2px 8px;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 0.2px;
            flex-shrink: 0;
        }

        .flow-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-color);
            line-height: 1.2;
        }

        .flow-note {
            font-size: 10px;
            color: #777;
            line-height: 1.4;
            margin-top: -6px;
        }

        .optional-badge {
            background: #FFF4E8;
            color: #9A5800;
            border: 1px solid #F3D3AA;
            border-radius: 999px;
            padding: 2px 8px;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 0.2px;
            flex-shrink: 0;
        }

        .section-tight {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .row {
            display: flex;
            gap: var(--spacing-md);
            align-items: center;
        }

        /* Status Notifications */
        .status {
            position: fixed;
            top: 12px;
            left: 12px;
            right: 12px;
            z-index: 100;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--radius-md);
            font-size: 11px;
            display: none;
            line-height: 1.4;
            animation: fadeIn 0.2s ease-in-out;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-2px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .status.show {
            display: block;
        }

        .status.success {
            background: var(--success-bg);
            color: var(--success-color);
            border: 1px solid var(--success-border);
        }

        .status.error {
            background: var(--error-bg);
            color: var(--error-color);
            border: 1px solid var(--error-border);
        }

        .status.info {
            background: #F0F9FF;
            color: #0077D4;
            border: 1px solid #BAE3FF;
        }

        /* Inline Error - now Block Error above button */
        /* Inline Error - now Block Error floating top */
        .error-message {
            position: fixed;
            top: 12px;
            left: 12px;
            right: 12px;
            z-index: 101;
            font-size: 11px;
            color: var(--error-color);
            background: var(--error-bg);
            border: 1px solid var(--error-border);
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--radius-md);
            display: none;
            animation: fadeIn 0.2s ease-in-out;
            text-align: left;
            line-height: 1.4;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .error-message.show {
            display: block;
        }

        /* Selection Indicator */
        .selection-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: var(--spacing-sm) var(--spacing-md);
            background: #F5F5F5;
            border-radius: var(--radius-md);
            font-size: 11px;
            color: var(--text-color);
            border: 1px solid transparent;
            transition: all 0.2s ease;
        }

        .selection-indicator.active {
            background: #EDF5FA;
            border-color: #BDE0F5;
            color: var(--primary-color);
        }

        .selection-indicator .icon {
            font-size: 12px;
            opacity: 0.7;
        }

        /* Icon placeholders - simplified as text for now, could be SVG */
        .icon-text {
            margin-right: 6px;
            font-size: 12px;
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: var(--text-color);
            margin-bottom: var(--spacing-xs);
        }

        .image-source-fields {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-sm);
        }

        .image-source-fields.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .hidden-input {
            display: none;
        }
    </style>
</head>

<body>
    <div class="container">

        <!-- Status Area (Moved to top) -->
        <div id="status" class="status"></div>

        <!-- Selection Indicator -->
        <div id="selection-indicator" class="selection-indicator">
            <span id="selection-icon" class="icon">‚¨ú</span>
            <span id="selection-text">No frame selected (REQUIRED)</span>
        </div>

        <div class="flow-card">
            <div class="flow-header">
                <span class="flow-step">Step 1</span>
                <span class="flow-title">Generate Localization Prompt</span>
            </div>
            <div class="flow-note">Set locales, generate the prompt, then run it in ChatGPT/Claude.</div>

            <div class="section-tight">
                <label class="label" for="languages">Target Languages</label>
                <input type="text" id="languages"
                    placeholder="e.g. de-DE, en-US, fr-FR, ja, ko, pt-BR, zh-Hans, zh-Hant"
                    value="de-DE, en-AU, en-CA, en-GB, en-US, es-ES, fr-FR, hi, id, it, ja, ko, pl, pt-BR, ru, th, tr, vi, zh-Hans, zh-Hant">
                <div class="hint">Comma-separated locale codes. Used for text localization and optional image matching.</div>
            </div>

            <div class="section-tight">
                <label class="label" for="prompt">Localization Prompt Template</label>
                <textarea id="prompt" class="tall">You are a senior localization specialist for mobile app UI copy.

## TASK
Translate UI strings to **match the original design's visual balance** while sounding natural and culturally native in each target language.

## CRITICAL CONSTRAINT: LENGTH + WIDTH FIT

### Target: Match `charCount` and fit likely width constraints

| Difference | Status | Action |
|------------|--------|--------|
| ¬±0-2 chars | ‚úÖ Ideal | Perfect match |
| ¬±3-5 chars | ‚ö†Ô∏è Acceptable | Try to get closer |
| +6 or more | ‚ùå Overflow | Rewrite shorter |
| -6 or more | ‚ùå Too short | Expand naturally |

**Why this matters:**
- Too long -> text overflows, truncates, breaks UI
- Too short -> awkward whitespace, unbalanced visual design
- Just right -> maintains designer's intended visual rhythm

### How to use the sizing fields
- `charCount`: primary target length.
- `lines`: estimated visible lines in the source design.
- `boxWidthPx`: width of the text box itself.
- `containerWidthPx`: width of the nearest container around the text.

Treat `charCount` as the main target, and use `boxWidthPx` / `containerWidthPx` to decide if wording must be shorter or can be slightly fuller.

### Width-aware length strategies

**If too long:**
- Drop articles (the, a, les, un, el)
- Use shorter synonyms
- Remove filler words
- Prefer compact punctuation and phrasing
- For narrow boxes, avoid long compounds and verbose clauses

**If too short:**
- Add natural particles/softeners
- Use slightly longer synonyms
- Add appropriate emphasis words
- Expand naturally without sounding formal or robotic

### Localization quality rule
For each string, optimize in this order:
1. Preserve meaning and intent.
2. Sound like a real local app (not textbook translation).
3. Fit likely width/line constraints using the provided sizing fields.
4. Keep close to `charCount` (ideally ¬±3).

---

## CULTURAL & LINGUISTIC NATURALNESS

Write like a native copywriter at a top local app - not a translator.

### Chinese (zh) ‚Äî Modern, casual Mainland style
| ‚ùå Avoid | ‚úÖ Use Instead |
|----------|---------------|
| Literary idioms (Â≠óÂ≠óÁè†Áéë, ‰∏ÄÁõÆ‰∫ÜÁÑ∂) | Conversational (ÊØèËØçÈÉΩÁÆó, Âø´ÈÄüÁúã) |
| Formal structure (ÊªëÂä®‰ª•ÊàêÈïø) | Natural flow (ÊªëÂä®ÂèòÂº∫, Ë∂äÂ≠¶Ë∂äÂ§ö) |
| Stiff verbs (Ëé∑Âèñ, Êî∂ÈõÜ) | Casual verbs (Êãø, ÈõÜ, Êîí) |

**Tone**: Â∞èÁ∫¢‰π¶, ÊäñÈü≥, Â§öÈÇªÂõΩ - friendly, playful, young

---

### Japanese (ja) ‚Äî Friendly, approachable
| ‚ùå Avoid | ‚úÖ Use Instead |
|----------|---------------|
| Formal (ÂèéÈõÜ„Åó„Åæ„Åó„Çá„ÅÜ) | Casual (ÈõÜ„ÇÅ„Çà„ÅÜ) |
| Stiff kanji-heavy | Mix hiragana for softness |
| Literal translations | Natural game/app phrasing |

**Tone**: Duolingo JP, LINE - warm, encouraging

---

### Korean (ko) ‚Äî Casual Ìï¥ÏöîÏ≤¥ or soft Î∞òÎßê
| ‚ùå Avoid | ‚úÖ Use Instead |
|----------|---------------|
| Formal (ÏàòÏßëÌïòÏÑ∏Ïöî, ÌöçÎìù) | Friendly (Î™®ÏïÑÎ¥ê, Î∞õÍ∏∞) |
| Corporate tone | Playful, youthful |

**Tone**: ÌÜ†Ïä§, ÎãπÍ∑ºÎßàÏºì - modern, friendly

---

### Spanish (es) ‚Äî Casual Latin American
| ‚ùå Avoid | ‚úÖ Use Instead |
|----------|---------------|
| Formal (Adquiera, Visualice) | Direct (Gana, Mira) |
| Wordy phrases | Punchy, short |

**Tone**: Duolingo ES - fun, direct

---

### French (fr) ‚Äî Casual tutoiement
| ‚ùå Avoid | ‚úÖ Use Instead |
|----------|---------------|
| Vous form | Tu form |
| Long phrases | Compact, modern |

**Tone**: French startup apps - casual, friendly

---

## QUALITY CHECKLIST (Per String)

1. **Length**: Is it within ¬±3 chars of `charCount`?
2. **Width Fit**: Is it likely to fit `boxWidthPx` / `containerWidthPx` without overflow?
3. **Natural**: Would a young native speaker say this?
4. **Tone**: Does it feel like a popular local app?
5. **No red flags**: Free of literary/formal/textbook phrasing?

---

## INPUT FORMAT
```json
{
  "texts": [
    {
      "id": "string",
      "text": "original text",
      "charCount": number,
      "lines": number,
      "boxWidthPx": number,
      "containerWidthPx": number
    }
  ],
  "targetLanguages": ["es", "fr", "ja", "zh", "ko"]
}
```

## OUTPUT FORMAT
Return **only valid JSON**.
```json
{
  "localizations": {
    "<lang_code>": {
      "<id>": "translated text"
    }
  }
}
```

---

**Translate the following, matching each string's target length and likely width fit:**
</textarea>
            </div>

            <button id="generate" class="btn btn-primary">
                <span class="icon-text">üìã</span> Generate & Copy Prompt
            </button>

            <div class="section-tight">
                <label class="label" for="generated-prompt">Generated Prompt</label>
                <textarea id="generated-prompt" readonly
                    placeholder="Generated prompt (with INPUT JSON) will appear here after you click Generate & Copy Prompt."></textarea>
                <div class="hint">If clipboard copy fails in Figma, copy from this box manually.</div>
                <button id="copy-generated-prompt" class="btn btn-secondary" type="button" style="margin-top:8px;">
                    <span class="icon-text">üìÑ</span> Copy Generated Prompt
                </button>
            </div>
        </div>

        <div class="flow-card">
            <div class="flow-header">
                <span class="flow-step">Step 2</span>
                <span class="flow-title">Apply Localized Content</span>
            </div>
            <div class="flow-note">Paste the AI JSON response and apply. Image replacement below is optional.</div>

            <div class="section-tight">
                <label class="label" for="response">Paste AI Response JSON</label>
                <textarea id="response" placeholder='{ "localizations": { "es": { ... } } }'></textarea>
            </div>

            <div class="flow-card" style="background:#FFF; border-style:dashed;">
                <div class="flow-header">
                    <span class="optional-badge">Optional</span>
                    <span class="flow-title">Replace i18n Images</span>
                </div>
                <div class="flow-note">You can leave this off and still apply text localizations normally.</div>

                <label class="checkbox-row" for="image-source-enabled">
                    <input type="checkbox" id="image-source-enabled">
                    <span>Enable localized image replacement</span>
                </label>

                <div id="image-source-fields" class="image-source-fields disabled">
                    <input type="file" id="image-source-folder-input" class="hidden-input" multiple webkitdirectory
                        directory accept=".png,.jpg,.jpeg,.webp">
                    <button id="choose-assets-folder" class="btn btn-secondary" type="button">
                        <span class="icon-text">üìÅ</span> Choose Assets Folder
                    </button>
                    <div id="image-source-summary" class="hint">No folder selected.</div>
                    <div class="hint">Expected structure: <code>&lt;root&gt;/&lt;locale&gt;/&lt;filename&gt;.&lt;ext&gt;</code></div>
                    <div class="hint">Allowed: <code>png, jpg, jpeg, webp</code> ¬∑ Max: <code>20MB</code>/file ¬∑ Up to
                        <code>5000</code> files
                    </div>
                </div>

                <div id="image-report-section" class="section" style="display:none;">
                    <button id="copy-image-report" class="btn btn-secondary" type="button">
                        <span class="icon-text">üßæ</span> Copy Image Mismatch Report
                    </button>
                </div>
            </div>

            <div class="section">
                <div id="apply-error" class="error-message"></div>
                <button id="apply" class="btn btn-success">
                    <span class="icon-text">‚ú®</span> Apply Localization
                </button>
            </div>
        </div>

        <!-- Footer -->
        <div style="text-align: right; color: #888; font-size: 10px; margin-top: -8px;">
            v0.0.2
        </div>

    </div>

    <script>
        const ALLOWED_IMAGE_EXTENSIONS = new Set(['png', 'jpg', 'jpeg', 'webp']);
        const MAX_IMAGE_BYTES = 20 * 1024 * 1024;
        const MAX_CATALOG_ENTRIES = 5000;

        const languagesInput = document.getElementById('languages');
        const promptTextarea = document.getElementById('prompt');
        const responseTextarea = document.getElementById('response');
        const imageSourceEnabledInput = document.getElementById('image-source-enabled');
        const imageSourceFields = document.getElementById('image-source-fields');
        const imageSourceFolderInput = document.getElementById('image-source-folder-input');
        const chooseAssetsFolderBtn = document.getElementById('choose-assets-folder');
        const imageSourceSummary = document.getElementById('image-source-summary');
        const imageReportSection = document.getElementById('image-report-section');
        const copyImageReportBtn = document.getElementById('copy-image-report');
        const generateBtn = document.getElementById('generate');
        const generatedPromptTextarea = document.getElementById('generated-prompt');
        const copyGeneratedPromptBtn = document.getElementById('copy-generated-prompt');
        const applyBtn = document.getElementById('apply');
        const statusDiv = document.getElementById('status');
        const selectionIndicator = document.getElementById('selection-indicator');
        const selectionText = document.getElementById('selection-text');
        const applyError = document.getElementById('apply-error');

        generateBtn.disabled = true;
        generateBtn.title = 'Please select a frame to generate prompt';
        generateBtn.style.opacity = '0.5';
        generateBtn.style.cursor = 'not-allowed';

        applyBtn.disabled = true;
        applyBtn.style.opacity = '0.5';
        applyBtn.style.cursor = 'not-allowed';
        applyBtn.title = 'Paste response JSON or enable image replacement';

        let extractedData = null;
        let statusTimeout = null;
        let saveLocalesTimeout = null;
        let savePromptTimeout = null;
        let saveImageSourceTimeout = null;
        let imageCatalog = null;
        const imageFilesByKey = new Map();
        let imageCatalogSummary = 'No folder selected.';
        let lastImageIssues = [];
        let lastGeneratedPrompt = '';
        let lastGenerateCopySucceeded = false;
        const IMAGE_DEBUG_ENABLED = true;

        function imageDebug(message, payload) {
            if (!IMAGE_DEBUG_ENABLED) return;
            if (payload !== undefined) {
                console.log(`[smartlocal:image-ui] ${message}`, payload);
                return;
            }
            console.log(`[smartlocal:image-ui] ${message}`);
        }

        function clearImageFilesMap() {
            imageFilesByKey.clear();
        }

        function setImageFilesMap(nextMap) {
            clearImageFilesMap();
            for (const [key, file] of nextMap.entries()) {
                imageFilesByKey.set(key, file);
            }
        }

        function getTargetLanguages() {
            return languagesInput.value
                .split(',')
                .map(value => value.trim())
                .filter(value => value.length > 0);
        }

        function saveLocales() {
            if (saveLocalesTimeout) clearTimeout(saveLocalesTimeout);
            saveLocalesTimeout = setTimeout(() => {
                parent.postMessage({
                    pluginMessage: {
                        type: 'save-locales',
                        locales: languagesInput.value
                    }
                }, '*');
            }, 500);
        }

        function savePrompt() {
            if (savePromptTimeout) clearTimeout(savePromptTimeout);
            savePromptTimeout = setTimeout(() => {
                parent.postMessage({
                    pluginMessage: {
                        type: 'save-prompt',
                        prompt: promptTextarea.value
                    }
                }, '*');
            }, 500);
        }

        function isImageSourceEnabled() {
            return Boolean(imageSourceEnabledInput.checked);
        }

        function updateImageSourceSummary() {
            imageSourceSummary.textContent = imageCatalogSummary;
        }

        function updateImageSourceFieldsState() {
            const enabled = isImageSourceEnabled();
            imageSourceFields.classList.toggle('disabled', !enabled);
        }

        function updateImageReportState() {
            imageReportSection.style.display = lastImageIssues.length > 0 ? 'flex' : 'none';
        }

        function updateApplyButtonState() {
            const hasResponse = responseTextarea.value.trim().length > 0;
            const imageModeReady = isImageSourceEnabled() && imageCatalog && imageCatalog.entries && imageCatalog.entries.length > 0;
            const canApply = hasResponse || imageModeReady;

            applyBtn.disabled = !canApply;
            applyBtn.style.opacity = canApply ? '1' : '0.5';
            applyBtn.style.cursor = canApply ? 'pointer' : 'not-allowed';

            if (canApply) {
                applyBtn.title = 'Apply localization';
            } else if (isImageSourceEnabled() && !imageCatalog) {
                applyBtn.title = 'Choose assets folder for image replacement';
            } else {
                applyBtn.title = 'Paste AI response JSON or enable image replacement';
            }
        }

        function saveImageSource() {
            if (saveImageSourceTimeout) clearTimeout(saveImageSourceTimeout);
            saveImageSourceTimeout = setTimeout(() => {
                parent.postMessage({
                    pluginMessage: {
                        type: 'save-image-source',
                        imageSource: {
                            enabled: isImageSourceEnabled()
                        }
                    }
                }, '*');
            }, 500);
        }

        function showStatus(message, type) {
            if (statusTimeout) {
                clearTimeout(statusTimeout);
                statusTimeout = null;
            }

            statusDiv.textContent = message;
            statusDiv.className = `status show ${type}`;

            statusTimeout = setTimeout(() => {
                hideStatus();
            }, 5000);
        }

        function hideStatus() {
            statusDiv.className = 'status';
            applyError.className = 'error-message';
            applyError.textContent = '';
        }

        function showApplyError(message) {
            applyError.textContent = message;
            applyError.className = 'error-message show';
        }

        function createImageFileKey(locale, relPath, size, lastModified, index) {
            return `${locale}::${relPath}::${size}::${lastModified}::${index}`;
        }

        function isLocaleLikeSegment(segment) {
            if (typeof segment !== 'string') return false;
            const value = segment.trim();
            if (!value) return false;
            return /^[A-Za-z]{2}(?:-[A-Za-z0-9]+)*$/.test(value);
        }

        function findLocaleIndex(pathSegments) {
            for (let i = 0; i < pathSegments.length - 1; i++) {
                if (isLocaleLikeSegment(pathSegments[i])) {
                    return i;
                }
            }
            return -1;
        }

        function buildImageCatalog(files) {
            imageDebug('catalog-build:start', { inputCount: files.length });
            const entries = [];
            const fileMap = new Map();
            const locales = new Set();
            const sampleLocaleMappings = [];
            let skippedUnsupported = 0;
            let skippedOversized = 0;
            let skippedNoLocale = 0;
            let exceededLimit = false;

            for (const file of files) {
                const relativePath = (file.webkitRelativePath || file.name || '').replace(/\\/g, '/').trim();
                if (!relativePath) {
                    skippedNoLocale++;
                    continue;
                }

                const pathSegments = relativePath.split('/').filter(Boolean);
                if (pathSegments.length < 2) {
                    skippedNoLocale++;
                    continue;
                }

                const localeIndex = findLocaleIndex(pathSegments);
                if (localeIndex < 0) {
                    skippedNoLocale++;
                    continue;
                }
                const locale = pathSegments[localeIndex].trim();
                const relPathFromLocale = pathSegments.slice(localeIndex).join('/');

                const filename = pathSegments[pathSegments.length - 1];
                const extMatch = filename.match(/\.([^.]+)$/);
                if (!extMatch) {
                    skippedUnsupported++;
                    continue;
                }

                const extension = extMatch[1].toLowerCase();
                if (!ALLOWED_IMAGE_EXTENSIONS.has(extension)) {
                    skippedUnsupported++;
                    continue;
                }

                if (file.size > MAX_IMAGE_BYTES) {
                    skippedOversized++;
                    continue;
                }

                if (entries.length >= MAX_CATALOG_ENTRIES) {
                    exceededLimit = true;
                    break;
                }

                const stem = filename.slice(0, -(extMatch[0].length)).trim();
                if (!stem) {
                    skippedUnsupported++;
                    continue;
                }

                const key = createImageFileKey(locale, relPathFromLocale, file.size, file.lastModified, entries.length);
                entries.push({
                    key,
                    locale,
                    relPath: relPathFromLocale,
                    stem,
                    extension,
                    size: file.size
                });
                fileMap.set(key, file);
                locales.add(locale);
                if (sampleLocaleMappings.length < 8) {
                    sampleLocaleMappings.push({
                        relativePath,
                        locale,
                        relPathFromLocale
                    });
                }
            }

            if (exceededLimit) {
                imageDebug('catalog-build:limit-exceeded', {
                    validEntryCount: entries.length,
                    max: MAX_CATALOG_ENTRIES
                });
                return {
                    catalog: null,
                    fileMap,
                    summary: `Catalog limit reached: maximum ${MAX_CATALOG_ENTRIES} valid files.`,
                    error: `Catalog limit exceeded. Keep at most ${MAX_CATALOG_ENTRIES} valid image files.`
                };
            }

            if (entries.length === 0) {
                imageDebug('catalog-build:no-valid-entries', {
                    skippedUnsupported,
                    skippedOversized,
                    skippedNoLocale
                });
                return {
                    catalog: null,
                    fileMap: new Map(),
                    summary: `No valid images found. Skipped ${skippedUnsupported} unsupported, ${skippedOversized} oversized, ${skippedNoLocale} missing-locale files.`,
                    error: null
                };
            }

            const now = new Date();
            const summary = `Loaded ${entries.length} images across ${locales.size} locales at ${now.toLocaleTimeString()}. Skipped ${skippedUnsupported} unsupported, ${skippedOversized} oversized, ${skippedNoLocale} missing-locale files.`;
            imageDebug('catalog-build:done', {
                entries: entries.length,
                localeCount: locales.size,
                skippedUnsupported,
                skippedOversized,
                skippedNoLocale,
                sampleLocaleMappings
            });

            return {
                catalog: {
                    version: 1,
                    mode: 'folder',
                    entries
                },
                fileMap,
                summary,
                error: null
            };
        }

        async function copyText(text) {
            try {
                await navigator.clipboard.writeText(text);
                return true;
            } catch (err) {
                try {
                    const textarea = document.createElement('textarea');
                    textarea.value = text;
                    document.body.appendChild(textarea);
                    textarea.select();
                    const copied = document.execCommand('copy');
                    document.body.removeChild(textarea);
                    return Boolean(copied);
                } catch (fallbackErr) {
                    return false;
                }
            }
        }

        languagesInput.addEventListener('input', saveLocales);
        promptTextarea.addEventListener('input', savePrompt);

        responseTextarea.addEventListener('input', () => {
            updateApplyButtonState();
            if (responseTextarea.value.trim().length > 0) hideStatus();
        });

        imageSourceEnabledInput.addEventListener('change', () => {
            updateImageSourceFieldsState();
            updateApplyButtonState();
            saveImageSource();
        });

        chooseAssetsFolderBtn.addEventListener('click', () => {
            imageSourceFolderInput.click();
        });

        imageSourceFolderInput.addEventListener('change', () => {
            const files = Array.from(imageSourceFolderInput.files || []);
            if (files.length === 0) {
                imageDebug('folder-select:empty-selection');
                return;
            }

            const result = buildImageCatalog(files);
            imageCatalog = result.catalog;
            setImageFilesMap(result.fileMap);
            imageCatalogSummary = result.summary;
            updateImageSourceSummary();
            updateApplyButtonState();

            if (result.error) {
                imageDebug('folder-select:error', { error: result.error });
                showApplyError(result.error);
            } else {
                imageDebug('folder-select:ready', {
                    entries: imageCatalog.entries.length
                });
                hideStatus();
                showStatus(`Assets loaded: ${imageCatalog.entries.length} files ready for matching.`, 'success');
            }
        });

        copyImageReportBtn.addEventListener('click', async () => {
            if (!lastImageIssues.length) {
                showStatus('No image mismatch report available yet.', 'info');
                return;
            }

            const report = {
                generatedAt: new Date().toISOString(),
                issueCount: lastImageIssues.length,
                issues: lastImageIssues
            };
            await copyText(JSON.stringify(report, null, 2));
            showStatus('Image mismatch report copied.', 'success');
        });

        copyGeneratedPromptBtn.addEventListener('click', async () => {
            if (!lastGeneratedPrompt) {
                showStatus('Generate a prompt first.', 'info');
                return;
            }

            const copied = await copyText(lastGeneratedPrompt);
            if (copied) {
                showStatus('Generated prompt copied.', 'success');
            } else {
                showStatus('Clipboard blocked. Copy manually from the Generated Prompt box.', 'error');
            }
        });

        generateBtn.onclick = () => {
            const languages = getTargetLanguages();
            if (languages.length === 0) {
                showStatus('Please enter at least one target language', 'error');
                return;
            }

            hideStatus();
            parent.postMessage({
                pluginMessage: {
                    type: 'generate-prompt',
                    languages,
                    promptTemplate: promptTextarea.value
                }
            }, '*');
        };

        applyBtn.onclick = () => {
            const responseText = responseTextarea.value.trim();
            const imageSourceEnabled = isImageSourceEnabled();
            const hasResponse = responseText.length > 0;

            if (!hasResponse && !imageSourceEnabled) {
                showApplyError('Please paste AI response JSON or enable image replacement.');
                return;
            }

            if (imageSourceEnabled && (!imageCatalog || !imageCatalog.entries || imageCatalog.entries.length === 0)) {
                showApplyError('Choose a localized assets folder before applying image replacement.');
                return;
            }

            hideStatus();

            const languages = getTargetLanguages();
            if (languages.length === 0) {
                showApplyError('Please enter at least one target language');
                return;
            }

            let localizations = {};
            if (hasResponse) {
                let response;
                try {
                    response = JSON.parse(responseText);
                } catch (err) {
                    showApplyError('Invalid JSON format. Please check the response or generate a new one.');
                    return;
                }

                if (!response.localizations || typeof response.localizations !== 'object') {
                    showApplyError('Missing "localizations" object in response');
                    return;
                }

                localizations = response.localizations;

                const missingLanguages = languages.filter(lang => !localizations[lang]);
                if (missingLanguages.length > 0) {
                    showApplyError(`Missing translations for: ${missingLanguages.join(', ')}`);
                    return;
                }

                if (extractedData && extractedData.texts) {
                    const textIds = extractedData.texts.map(item => item.id);
                    for (const lang of languages) {
                        const langData = localizations[lang];
                        const missingIds = textIds.filter(id => !Object.prototype.hasOwnProperty.call(langData, id));
                        if (missingIds.length > 0) {
                            showApplyError(`Missing text IDs for ${lang}: ${missingIds.length} items`);
                            return;
                        }
                    }
                }
            }

            parent.postMessage({
                pluginMessage: {
                    type: 'apply-localization',
                    localizations,
                    locales: languages,
                    imageSource: {
                        enabled: imageSourceEnabled,
                        mode: 'folder',
                        catalog: imageSourceEnabled ? imageCatalog : null
                    }
                }
            }, '*');
            imageDebug('apply-sent', {
                locales: languages,
                hasResponse,
                imageSourceEnabled,
                catalogEntries: imageSourceEnabled && imageCatalog ? imageCatalog.entries.length : 0
            });
        };

        window.onmessage = async (event) => {
            const msg = event.data.pluginMessage;
            if (!msg) return;

            if (msg.type === 'request-image-bytes') {
                const requestId = typeof msg.requestId === 'string' ? msg.requestId : '';
                const fileKey = typeof msg.fileKey === 'string' ? msg.fileKey : '';
                const file = imageFilesByKey.get(fileKey);
                imageDebug('bytes-request:received', { requestId, fileKey, hasFile: Boolean(file) });

                if (!requestId || !fileKey || !file) {
                    parent.postMessage({
                        pluginMessage: {
                            type: 'image-bytes-response',
                            requestId,
                            fileKey,
                            ok: false,
                            error: 'File not found'
                        }
                    }, '*');
                    return;
                }

                try {
                    const bytes = new Uint8Array(await file.arrayBuffer());
                    imageDebug('bytes-request:success', { requestId, fileKey, byteLength: bytes.byteLength });
                    parent.postMessage({
                        pluginMessage: {
                            type: 'image-bytes-response',
                            requestId,
                            fileKey,
                            ok: true,
                            bytes: Array.from(bytes)
                        }
                    }, '*');
                } catch (err) {
                    imageDebug('bytes-request:failed', { requestId, fileKey });
                    parent.postMessage({
                        pluginMessage: {
                            type: 'image-bytes-response',
                            requestId,
                            fileKey,
                            ok: false,
                            error: 'Read failed'
                        }
                    }, '*');
                }
                return;
            }

            if (msg.type === 'copy-to-clipboard') {
                lastGeneratedPrompt = typeof msg.text === 'string' ? msg.text : '';
                generatedPromptTextarea.value = lastGeneratedPrompt;
                lastGenerateCopySucceeded = await copyText(lastGeneratedPrompt);
                return;
            }

            if (msg.type === 'prompt-generated') {
                extractedData = msg.extractedData;
                const textCount = typeof msg.textCount === 'number' ? msg.textCount : 0;
                if (lastGenerateCopySucceeded) {
                    showStatus(`Prompt copied! Found ${textCount} text nodes.`, 'success');
                } else {
                    showStatus(`Prompt generated (clipboard blocked). Found ${textCount} text nodes. Copy from Generated Prompt box.`, 'info');
                }
                return;
            }

            if (msg.type === 'prompt-error') {
                showStatus(msg.message, 'error');
                return;
            }

            if (msg.type === 'apply-success') {
                const imageReplacedCount = typeof msg.imageReplacedCount === 'number' ? msg.imageReplacedCount : 0;
                const imageSkippedCount = typeof msg.imageSkippedCount === 'number' ? msg.imageSkippedCount : 0;
                const imageAmbiguousCount = typeof msg.imageAmbiguousCount === 'number' ? msg.imageAmbiguousCount : 0;
                const imageFailedCount = typeof msg.imageFailedCount === 'number' ? msg.imageFailedCount : 0;
                lastImageIssues = Array.isArray(msg.imageIssues) ? msg.imageIssues : [];
                updateImageReportState();
                imageDebug('apply-success', {
                    frameCount: msg.frameCount,
                    imageReplacedCount,
                    imageSkippedCount,
                    imageAmbiguousCount,
                    imageFailedCount,
                    issueCount: lastImageIssues.length
                });

                showStatus(
                    `Success! Created ${msg.frameCount} localized frames. Images: ${imageReplacedCount} replaced, ${imageSkippedCount} skipped, ${imageAmbiguousCount} ambiguous, ${imageFailedCount} failed.`,
                    'success'
                );
                return;
            }

            if (msg.type === 'apply-error') {
                showStatus(msg.message, 'error');
                return;
            }

            if (msg.type === 'selection-changed') {
                const isValid = Boolean(msg.isValid);
                const nodeName = typeof msg.nodeName === 'string' ? msg.nodeName : '';
                const message = typeof msg.message === 'string' ? msg.message : '';

                if (isValid) {
                    selectionIndicator.classList.add('active');
                    selectionText.textContent = `Selected: ${nodeName}`;
                    generateBtn.disabled = false;
                    generateBtn.title = 'Generate prompt for selected frame';
                    generateBtn.style.opacity = '1';
                    generateBtn.style.cursor = 'pointer';
                } else {
                    selectionIndicator.classList.remove('active');
                    selectionText.textContent = message || 'No frame selected (REQUIRED)';
                    generateBtn.disabled = true;
                    generateBtn.title = message || 'Please select a frame';
                    generateBtn.style.opacity = '0.5';
                    generateBtn.style.cursor = 'not-allowed';
                }
                return;
            }

            if (msg.type === 'load-saved-settings') {
                if (msg.locales !== null && msg.locales !== undefined) {
                    languagesInput.value = msg.locales;
                }

                if (msg.prompt !== null && msg.prompt !== undefined) {
                    promptTextarea.value = msg.prompt;
                }

                imageSourceEnabledInput.checked = Boolean(msg.imageSourceEnabled);
                updateImageSourceFieldsState();
                updateApplyButtonState();
            }
        };

        updateImageSourceSummary();
        updateImageSourceFieldsState();
        updateApplyButtonState();
        updateImageReportState();

        parent.postMessage({ pluginMessage: { type: 'ui-ready' } }, '*');
    </script>
</body>

</html>
